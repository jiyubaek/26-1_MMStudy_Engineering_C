# [3주차] 빅데이터를 지탱하는 기술

## 데이터 수집 파이프라인

![image.png](image.png)

열 지향 스토리지

- 테이블의 데이터를 **행(row) 단위가 아니라 열(column) 단위로 저장하는 방식**
    - 같은 속성(컬럼) 데이터끼리 모아서 저장
    - 대규모 **분석·집계(OLAP)** 작업에 최적화
    
    ### 행지향 스토리지
    
    - 한 **행 전체를 연속 저장**
    - 장점
        - INSERT / UPDATE 빠름
        - 특정 한 사람 조회 빠름
    - 단점
        - 분석 시 불필요한 컬럼까지 읽음
    
    예: MySQL, PostgreSQL, Oracle
    

### 열지향 스토리지

- 같은 열 데이터만 연속 저장
- 특징
    - 분석·집계 압도적으로 빠름
    - 압축 효율 높음
- 단점
    - 한 행 전체 조회 느림
    - 잦은 업데이트에 불리
- 예: Nosql,  HBase, Cassandra, Redshift, BigQuery

---

## Q. 왜 열지향이 분석에 강한가?

### 행지향

- **모든 컬럼을 읽음 →** 디스크 I/O 낭비

### 열지향

- **필요한 컬럼만 읽음 →**필요한 데이터만 접근 **→ I/O 감소 = 속도 급상승**

---

## Q. NoSQL이 ‘정확성(Consistency)’을 일부 포기하는 이유

NoSQL은 ‘항상 정확한 값’보다 ‘항상 응답하는 시스템’을 선택한다.

## CAP 이론

분산 시스템에서는 **아래 3가지를 동시에 만족할 수 없다**.

| 요소 | 의미 |
| --- | --- |
| Consistency (일관성) | 모든 노드가 같은 데이터를 봄 |
| Availability (가용성) | 요청이 항상 응답을 받음 |
| Partition Tolerance (분할 허용) | 네트워크 장애를 견딤 |

NoSQL은 **분산 시스템**이기 때문에 **네트워크 장애(P)** 가 반드시 발생한다. 따라서 AP or CP 중 선택해야한다. 

NoSQL은 보통 **AP를 선택한다.** 네트워크가 끊겨서 일부 노드만 살아 있어도 **일단 응답은 준다.**

 그 결과 노드마다 데이터가 잠시 다를 수 있다.  

→ **정확성(Consistency) 일부 포기**

데이터가 다른 채로 남지 않고 최종 일관성(Eventually Consistency)을 사용한다. 따라서 지금은 다를 수 있지만, 시간이 지나면 결국 같아진다.

예를 들면 sns 에서 좋아요 수가 1~2개 차이나는 건 괜찮지만, 서비스가 안 열리면 안되는 경우 → sp nosql 사용

CP NoSQL는?

분산 환경에서 네트워크 분할이나 장애가 발생하더라도 **데이터의 정확성과 일관성을 유지하는 것을 최우선 목표**로 삼는다. 일부 노드에 문제가 발생했을 때, **불완전하거나 오래된 데이터를 반환하기보다는 아예 응답을 거부하거나 대기 상태로 두는 방식**을 의미한다.

“어떤 서비스에서 더 중요한 가치가 무엇인가”에 따라 선택

## Q. CAP 정리는 “선택”이 아니라 “상황 판단” 아닌가?

CAP는 “고정된 성질”이 아니라 **장애 상황에서의 시스템 행동을 설명하는 모델**이다.

## Q.왜 ACID와 CAP는 같이 만족되기 어려울까

ACID는 본래 **단일 데이터베이스(또는 단일 노드)** 환경에서, 트랜잭션의 신뢰성을 보장하기 위해 설계된 개념이다. 이때 핵심 전제는 **데이터가 하나의 논리적 장소에 있고, 중앙에서 제어 가능하다**는 점이다. 이 환경에서는 트랜잭션의 원자성, 일관성, 독립성, 지속성을 비교적 명확하게 구현할 수 있다.

그러나 시스템이 **분산 환경**으로 확장되면서 문제가 발생한다. 데이터가 여러 노드에 복제되고, 네트워크를 통해 통신해야 하는 상황에서는 **노드 간 상태를 항상 동일하게 유지하는 것**이 매우 어려워진다. 특히 네트워크 지연이나 단절과 같은 문제가 발생하면, 일부 노드는 최신 데이터를 알고 있고 다른 노드는 그렇지 못한 상태가 된다.

→ CAP 이론

## Q.NoSQL은 ACID를 어떻게 “포기”했을까?

NoSQL은 전체 시스템 수준의 ACID를 포기하거나 완화하고, 부분적인 ACID만 선택적으로 유지

대규모 분산 환경에서는 **모든 노드에 대해 강한 일관성과 고립성을 유지하는 비용이 지나치게 크기 때문에 네트워크 지연, 장애, 노드 증가에 따라 성능과 확장성이 급격히 떨어진다.**

Atomicity (원자성): 로컬 단위로 유지

-**단일 레코드(또는 단일 키)** 에 대해서는 원자성을 보장한다.
ex) 하나의 문서나 하나의 RowKey에 대한 업데이트는 “전부 성공 또는 전부 실패”로 처리
- 여러 키나 여러 파티션에 걸친 트랜잭션에 대해서는 **전통적인 원자성을 보장하지 않는다**. 전역 트랜잭션은 제한되거나 아예 제공되지 않는 경우가 많다.

Consistency(무결성): 분산 일관성으로 이동

-RDB에서의 Consistency는 무결성 제약조건을 의미하지만, NoSQL에서는 이 개념이 **분산 일관성 문제(CAP의 Consistency)** 와 섞이게 된다.
- NoSQL은 즉시 모든 노드가 같은 값을 보장하지 않으며 대신 **Eventually Consistency(결과적 일관성)** 를 채택한다

Isolation (독립성): 약화 또는 포기

-동시 트랜잭션 간 완전한 고립성을 제공하지 않는 경우가 많다.

-다른 트랜잭션의 중간 결과를 볼 가능성이 있으며, 이는 성능과 확장성을 확보하기 위한 선택이다.

Durability (지속성)

-NoSQL도 트랜잭션이 성공한 데이터가 사라지지 않도록 보장하려 한다. 

-RDB처럼 즉시 디스크에 기록하기보다는 비동기 복제, 로그 기반 복구, 다중 노드 복제 등을 활용해 **시스템 전체 차원의 내구성**을 확보

- 메시지 브로커 개념
    
    스토리지의 성능 문제를 해결하기 위해 메시지 배송 시스템에서 데이터를 일시적으로 축적하는 중간층
    
    데이터를 분산 스토리지에 저장할 때 주의
    
    -쓰기 빈도가 증가하면 디스크 성능 한계
    
    - 외부에서 오는 메시지양 제어 불가→급격한 데이터양 증가 대응 어려움
    - 쓰기 성능 한계에 의해 오류 발생시 클라이언트가 메시지를 “재전송” → 부하가 높아짐 → 쓰기 성능 높이기 vs 클라이언트가 재전송 포기할 때까지 기다리기
    - 성능이 매우 높고 필요에 따라 성능을 올릴 수 있는 스토리지가 필요 ← 분산 스토리지는 못함.
    - open sourse: Apache Kafka / cloud: Amazon kinesis
    
    Push형: 송신 측 제어로 데이터를 보내는 방식
    
    Pull형: 수신 측 제어로 데이터를 가져오는 방식
    
    → 메시지 브로커는 데이터 쓰기 속도 조정을 위한 “완충” 부분 
    
    → push 형에서 풀pull형으로 매시지 배송의 타이밍을 변환
    
    생산자: 메시지 브로커에 데이터를 넣는 것(push)
    
    소비자: 메시지 브로커에 데이터를 꺼내오는 것(pull)
    
    → 메시지 브로커는 높은 빈도로 데이터 쓰는 것에 최적화 됨
    
    → 여러 대의 노드에 부하 분산함. “뛰어난 확장성”
    
    push형의 메시지 배송: 모두 메시지 브로커에 집중시키고 일정 빈도로 꺼낸 데이터를 분산 스토리지에 기록
    
    pull형의 메시지 배송: 대량의 메시지를 메시지 브로커에 저장해 뒀다가 적당히 모아진 데이터를 분산 스토리지에 기록 —> 파일 사이즈 적정화
    
    ![image.png](image%201.png)
    
    스트림 처리(stream processing): 메시지 브로커에서 짧은 간격으로 데이터를 꺼내서 처리함
    
    메시지 라우팅(message routing): 메시지 브로커에 써넣은 데이터를 복수의 소비자에서 읽어들여 메시지가 복사되어 여러 경로로 분산되는 것
    
    메시지 배송의 신뢰성 문제
    
    메시지의 중복 / 누락 처리 방법
    
    at most once : 메시지 1회 전송. 전송 실패 가능 (손실 O)
    
    → 송신 측 재전송으로 인한 중복
    
    exactly once : 메시지 1회 전송. 전송 성공(손실X 중복 X)
    
    → 코디네이터 부재시 합의 필요
    
    at least once : 메시지 n회 전송. 전송 성공(중복 O)
    
    → 중복제거 이용 → 시퀀스 번호(성능향상 어려움)
    
    중복제거 방법
    
    1. 오프셋
    
    같은 오프셋은 덮어씀
    
    1. 고유 ID
    
    최근 ID만 기억 ( 이후 ID 중복 허용)
    
    신뢰성이 높은 메시지 배송 실행 방법
    
    - 경로를 모두 at least once로 통일 후 모든 메시지에 고유ID 포함하도록 하고 말단에서 중복 제거
    - Nosql (Group Bym DISTINCT)